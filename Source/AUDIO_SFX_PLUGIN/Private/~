

	// Apply time stretching
	U OutputSampleIndex = 0;  StretchRatio;
	for (U Channel = 0; Channel < NumChannels; Channel++)
	{
		oBuffer[Channel] = VectorT<T>(NumSamples);
		for (U Sample = 0; Sample < NumSamples; Sample++)
		{
			oBuffer[Channel][Sample] = (1 - Sample) * oBuffer[Channel][Sample] + Sample * oBufferTemp[Channel][Sample];
		}
	}

    // Apply time stretching
	U OutputSampleIndex = 0;  StretchRatio;
	for (U Channel = 0; Channel < NumChannels; Channel++)
	{
		oBuffer[Channel] = VectorT<T>(NumSamples);
		for (U Sample = 0; Sample < NumSamples; Sample++)
		{
			oBuffer[Channel][Sample] = oBufferTemp[Channel][OutputSampleIndex];
		}
		OutputSampleIndex++;
	}
    
    // Apply time stretching
	U OutputSampleIndex = 0;  StretchRatio;
	for (U Channel = 0; Channel < NumChannels; Channel++)
	{
		oBuffer[Channel] = VectorT<T>(NumSamples);
		for (U Sample = 0; Sample < NumSamples; Sample++)
		{
			oBuffer[Channel][Sample] = oBufferTemp[Channel][OutputSampleIndex];
		}
		OutputSampleIndex += StretchRatio;
	}

	public:
		void SetSize(FILEINFO_Obj<T, U>&);
		void SetDamping(FILEINFO_Obj<T, U>&);
		void SetWetLevel(FILEINFO_Obj<T, U>&);
		void SetDryLevel(FILEINFO_Obj<T, U>&);
	private:
		T& AudioBufferPrivateFloat64TRef;
		T& AudioBufferTempPrivateFloat64TRef;
		U NumChannelsPrivateUint64T;
		U NumSamplesPrivateUint64T;
		U NumSamplesPerChannelPrivateUint64T;
		U SampleRatePrivateUint64T;
		U SizePrivateUint64T;
		T WetLevelPrivateFloat64T;
		T DryLevelPrivateFloat64T;
		T DampingPrivateFloat64T;

    U PlateReverbNumChannelsUint64T;
    U PlateReverbNumSamplesUint64T;
    U PlateReverbNumSamplesPerChannelUint64T;
    T PlateReverbSampleRateFloat64T;
    T PlateReverbWetLevelFloat64T;
    T PlateReverbDryLevelFloat64T;
    T PlateReverbDampingFloat64T;

/**
* Plate Reverb synthesis tool
* @param [ PlateReverbDamping ] --- Damping level
* @param [ PlateReverbDrynessFloat64T ] --- Dryness of the reverb
* @param [ PlateReverbWetnessFloat64T ] --- Wetness of the reverb
* @param [ PlateReverb3DVectorTRef[0] ] --- Original file
* @returns [ PlateReverb3DVectorTRef[1] ] --- Returns result
*/
template<typename T, typename U>
void PlateReverb<T, U>::GeneratePlateReverb(
	FILEINFO_Obj<T, U>& FileInfoObj_Ref
	)
{
	// Loop through the channels
	for (U nChannelUInt64 = 0; nChannelUInt64 < FileInfoObj_Ref.PlateReverb3DVectorTRef[0].size(); nChannelUInt64++)
	{
		// Loop through the samples
		for (U nSampleIdxUInt64 = 0; nSampleIdxUInt64 < PlateReverb3DVectorTRef[0][nChannelUInt64].size(); nSampleIdxUInt64++)
		{
			// Apply the plate algorithm
			FileInfoObj_Ref.PlateReverb3DVectorTRef[1][nChannelUInt64][nSampleIdxUInt64] =
				FileInfoObj_Ref.PlateReverb3DVectorTRef[0][nChannelUInt64][nSampleIdxUInt64] *
				(1 - FileInfoObj_Ref.PlateReverbWetnessFloat64T) +
				(
					(
						FileInfoObj_Ref.PlateReverbWetnessFloat64T * 
						FileInfoObj_Ref.PlateReverbDampingFloat64T
					) *
					FileInfoObj_Ref.PlateReverb3DVectorTRef[0][nChannelUInt64][nSampleIdxUInt64] +
					FileInfoObj_Ref.PlateReverb3DVectorTRef[1][nChannelUInt64][nSampleIdxUInt64 - 1]
				);
		}
	}
}

template <typename T>
std::unordered_map<enum class ConvolutionReverbEnumFLAGS, Vector2DT<T>> PopulateConvolutionReverbHashTableT()
{
    ConvolutionReverbHashTableT<ConvolutionReverbEnumFLAGS, Vector2DT<T>> ConvolutionReverbHashTableT;
    
    ConvolutionReverbHashTableT[ConvolutionReverbEnumFLAGS::ConvolutionReverbPlateEnumFlag] = 
        ConvolutionReverbFIRObj<T>::PlateFiniteImpulseResponseFIRVector2DT;
    ConvolutionReverbHashTableT[ConvolutionReverbEnumFLAGS::ConvolutionReverbSpringEnumFlag] =
        ConvolutionReverbFIRObj<T>::SpringFiniteImpulseResponseFIRVector2DT;
    ConvolutionReverbHashTableT[ConvolutionReverbEnumFLAGS::ConvolutionReverbConvoluteEnumFlag] = 
        ConvolutionReverbFIRObj<T>::ConvolutionFiniteImpulseResponseFIRVector2DT;
    ConvolutionReverbHashTableT[ConvolutionReverbEnumFLAGS::ConvolutionReverbWoodenEnumFlag] = 
        ConvolutionReverbFIRObj<T>::AlgorithmicObj::SmallRoomObj::WoodenRoomFiniteImpulseResponseFIRVector2DT;
    ConvolutionReverbHashTableT[ConvolutionReverbEnumFLAGS::ConvolutionReverbGlassEnumFlag] = 
        ConvolutionReverbFIRObj<T>::AlgorithmicObj::SmallRoomObj::GlassRoomFiniteImpulseResponseFIRVector2DT;
    ConvolutionReverbHashTableT[ConvolutionReverbEnumFLAGS::ConvolutionReverbTitaniumEnumFlag] = 
        ConvolutionReverbFIRObj<T>::AlgorithmicObj::SmallRoomObj::MetalObj::TitaniumRoomFiniteImpulseResponseFIRVector2DT;
    ConvolutionReverbHashTableT[ConvolutionReverbEnumFLAGS::ConvolutionReverbIronEnumFlag] = 
        ConvolutionReverbFIRObj<T>::AlgorithmicObj::SmallRoomObj::MetalObj::IronRoomFiniteImpulseResponseFIRVector2DT;
    ConvolutionReverbHashTableT[ConvolutionReverbEnumFLAGS::ConvolutionReverbLeadEnumFlag] = 
        ConvolutionReverbFIRObj<T>::AlgorithmicObj::SmallRoomObj::MetalObj::LeadRoomFiniteImpulseResponseFIRVector2DT;
    ConvolutionReverbHashTableT[ConvolutionReverbEnumFLAGS::ConvolutionReverbGoldEnumFlag] = 
        ConvolutionReverbFIRObj<T>::AlgorithmicObj::SmallRoomObj::MetalObj::GoldRoomFiniteImpulseResponse;
	ConvolutionReverbHashTableT[ConvolutionReverbEnumFLAGS::ConvolutionReverbSteelEnumFlag] = 
        ConvolutionReverbFIRObj<T>::AlgorithmicObj::SmallRoomObj::MetalObj::SteelRoomFiniteImpulseResponseFIRVector2DT;
	ConvolutionReverbHashTableT[ConvolutionReverbEnumFLAGS::ConvolutionReverbAluminumEnumFlag] = 
        ConvolutionReverbFIRObj<T>::AlgorithmicObj::SmallRoomObj::MetalObj::AluminumRoomFiniteImpulseResponseFIRVector2DT;
	ConvolutionReverbHashTableT[ConvolutionReverbEnumFLAGS::ConvolutionReverbRubberEnumFlag] = 
        ConvolutionReverbFIRObj<T>::AlgorithmicObj::SmallRoomObj::RubberRoomFiniteImpulseResponseFIRVector2DT;
	ConvolutionReverbHashTableT[ConvolutionReverbEnumFLAGS::ConvolutionReverbCeramicEnumFlag] = 
        ConvolutionReverbFIRObj<T>::AlgorithmicObj::SmallRoomObj::CeramicRoomFiniteImpulseResponseFIRVector2DT;
	ConvolutionReverbHashTableT[ConvolutionReverbEnumFLAGS::ConvolutionReverbPlasticEnumFlag] = 
        ConvolutionReverbFIRObj<T>::AlgorithmicObj::SmallRoomObj::PlasticRoomFiniteImpulseResponseFIRVector2DT;
	ConvolutionReverbHashTableT[ConvolutionReverbEnumFLAGS::ConvolutionReverbCottonEnumFlag] = 
        ConvolutionReverbFIRObj<T>::AlgorithmicObj::SmallRoomObj::CottonRoomFiniteImpulseResponseFIRVector2DT;
	ConvolutionReverbHashTableT[ConvolutionReverbEnumFLAGS::ConvolutionReverbMediumHallEnumFlag] = 
        ConvolutionReverbFIRObj<T>::AlgorithmicObj.MediumHallFiniteImpulseResponseFIRVector2DT;
	ConvolutionReverbHashTableT[ConvolutionReverbEnumFLAGS::ConvolutionReverbConcertHallEnumFlag] = 
        ConvolutionReverbFIRObj<T>::AlgorithmicObj::ConcertHallFiniteImpulseResponseFIRVector2DT;
	ConvolutionReverbHashTableT[ConvolutionReverbEnumFLAGS::ConvolutionReverbCathedralEnumFlag] = 
        ConvolutionReverbFIRObj<T>::AlgorithmicObj::CathedralFiniteImpulseResponseFIRVector2DT;
	ConvolutionReverbHashTableT[ConvolutionReverbEnumFLAGS::ConvolutionReverbConcertStadiumEnumFlag] = 
        ConvolutionReverbFIRObj<T>::AlgorithmicObj::ConcertStadiumFiniteImpulseResponseFIRVector2DT;
	return ConvolutionReverbHashTableT;
}

template <typename T>
ConvolutionReverbHashTableT<T>[ConvolutionReverbEnumFLAGS::ConvolutionReverbPlateEnumFlag] = ConvolutionReverbFIRObj<T>::PlateFiniteImpulseResponseFIRVector2DT;

	switch (FileInfoObjRef.ConvolutionReverbMethodEnumFlag)
	{
	case FileInfoObjRef.ConvolutionReverbEnumFlags::ConvolutionReverbPlateEnumFlag:
	case FileInfoObjRef.ConvolutionReverbEnumFlags::ConvolutionReverbSpringEnumFlag:
	case FileInfoObjRef.ConvolutionReverbEnumFlags::ConvolutionReverbConvoluteEnumFlag:
	case FileInfoObjRef.ConvolutionReverbEnumFlags::ConvolutionReverbWoodenEnumFlag:
	case FileInfoObjRef.ConvolutionReverbEnumFlags::ConvolutionReverbGlassEnumFlag:
	case FileInfoObjRef.ConvolutionReverbEnumFlags::ConvolutionReverbTitaniumEnumFlag:
	case FileInfoObjRef.ConvolutionReverbEnumFlags::ConvolutionReverbIronEnumFlag:
	case FileInfoObjRef.ConvolutionReverbEnumFlags::ConvolutionReverbLeadEnumFlag:
	case FileInfoObjRef.ConvolutionReverbEnumFlags::ConvolutionReverbGoldEnumFlag:
	case FileInfoObjRef.ConvolutionReverbEnumFlags::ConvolutionReverbSteelEnumFlag:
	case FileInfoObjRef.ConvolutionReverbEnumFlags::ConvolutionReverbAluminumEnumFlag:
	case FileInfoObjRef.ConvolutionReverbEnumFlags::ConvolutionReverbRubberEnumFlag:
	case FileInfoObjRef.ConvolutionReverbEnumFlags::ConvolutionReverbCeramicEnumFlag:
	case FileInfoObjRef.ConvolutionReverbEnumFlags::ConvolutionReverbPlasticEnumFlag:
	case FileInfoObjRef.ConvolutionReverbEnumFlags::ConvolutionReverbCottonEnumFlag:
	case FileInfoObjRef.ConvolutionReverbEnumFlags::ConvolutionReverbMediumHallEnumFlag:
	case FileInfoObjRef.ConvolutionReverbEnumFlags::ConvolutionReverbConcertHallEnumFlag:
	case FileInfoObjRef.ConvolutionReverbEnumFlags::ConvolutionReverbCathedralEnumFlag:
	case FileInfoObjRef.ConvolutionReverbEnumFlags::ConvolutionReverbConcertStadiumEnumFlag:
		ConvolutionTargetFIRVector2DTREF = 
			FileInfoObjRef.ConvolutionReverbImpulseResponseTObj.ConcertHallFiniteImpulseResponseFIRVector2DT;
		break;

	default: // FileInfoObjRef.ConvolutionReverbNoneSelectedEnumFlag
		std::cout << "Error - ConvolutionReverb::GenerateConvolutionReverb FileInfoObjRef.ConvolutionReverbNoneSelectedEnumFlag. " << std::endl;
		return;
	}	

template <typename T, typename U>
using HashMapT = std::unordered_map<T, U>;

template <typename T>
HashMapT <enum class ConvolutionReverbEnumFLAGS, Vector2DT<T>> ConvolutionReverbHashTableT = HashMapT<ConvolutionReverbEnumFLAGS, Vector2DT<T>>;

template <typename T, typename U>
ConvolutionReverbHashTableT[ConvolutionReverbEnumFLAGS::ConvolutionReverbPlateEnumFlag] = ConvolutionReverbFIRObj<T, U>::PlateFiniteImpulseResponseFIRVector2DT<T, U>;

		// Average the audio for the entire channel
		FileInfoObjRef.AudioMixMixedAudioResultVector2DTRef[nChannelUInt64] /= 
			FileInfoObjRef.AudioMixFileAVector2DTRef.size();
            
	VectorT<T> TimeVector;
	VectorT<U> AmplitudeVector;
	T GlobalSampleRate;
	T WaveSpeed;
	T WaveLength;
	T StartTime;
	T GlobalAmplitude;
	T GlobalFrequency;
	T AmplitudeDecibels;
	T AmplitudeDecibelsNormalized;

        void BluesteinFFT(
            FILEINFO_Obj<T,U>& FileInfoObj,
            ComplexVector3DT<T>&
            );
        void Radix2FFT(
            FILEINFO_Obj<T,U>& FileInfoObj,
            ComplexVector3DT<T>&
            );

    /**
    * TemporaryAudioFileComplexVector2DTRef[AudioChannel][Stream]
    */
    ComplexVector2DT<T>& TemporaryAudioFileComplexVector2DTRef;
    /**
    * ProjectFilesComplexVector2DFloat64T[AudioFile][AudioChannel][Stream]
    */
    ComplexVector3DT<T>& ProjectFileComplexVector3DTRef;

    switch (FileInfoObj.AudioEqualizationAlgorithmEnum)
    {
        bool ProperCallBool = false;
        case FILEINFO_Obj::AudioEqualizationENUM::Blustein:
            BluesteinFFT(FileInfoObj, {});
            break;
        case FILEINFO_Obj::AudioEqualizationENUM::Radix2:
            Radix2FFT(FileInfoObj, {});
            break;
        case FILEINFO_Obj::AudioEqualizationENUM::CooleyTukey:
            ProperCallBool = true;
        default:
            if(!ProperCallBool)
            {
                std::cout << "Error - AudioEqualization<T>::ApplyAudioEqualizationFilterT : invalid FileInfoObj.AudioEqualizationAlgorithmEnum" << std::endl;
            }
            FileInfoObj.TemporaryAudioFileComplexVectorTRef =
                ComplexVectorT<T>(FileInfoObj.NoiseBufferVectorTRef.size());
            CooleyTukeyFFT(FileInfoObj, FileInfoObj.NoiseBufferVectorTRef);
            NormalizeAudioT(NoiseBufferComplexVectorTRef);
            CooleyTukeyFFT(FileInfoObj, {});
            std::transform(
                NoiseBufferComplexVectorTRef.begin(),
                NoiseBufferComplexVectorTRef.end(),
                [](ComplexT<T> x)
                {
                    return static_cast<T>(x / NoiseBufferComplexVectorTRef.size());
                }
            );
            break;
    }

    ComplexVector2DT<T> NoiseBufferComplexVectorTRef = ComplexVector2DT<T>(FileInfoObj.NoiseBufferVectorTRef.size());

    for (T idxComplexVectorT : NoiseBufferComplex2DT)
    {
        ComplexVectorT idxComplexVectorT = ComplexT<T>(
            std::cos(2 * static_cast<T>(UE_FLOAT64_PI) / nUInt64),
            std::sin(2 * static_cast<T>(UE_FLOAT64_PI) / nUInt64)
            );
    }

    if(!AtHighestScopeLevelBool)
    {
        for (U iUInt64 = 0; iUInt64 < nHalfRangeUInt64; iUInt64++)
        {
            EvenComplexVectorT[iUInt64] = NoiseBufferComplexVectorTRef[iUInt64 * 2];
            OddComplexVectorT[iUInt64] = NoiseBufferComplexVectorTRef[iUInt64 * 2 + 1];
        }
    }
    else
    {
        for (U iUInt64 = 0; iUInt64 < nHalfRangeUInt64; iUInt64++)
        {
            EvenComplexVectorT[iUInt64].real(FileInfoObj.NoiseBufferVectorTRef[iUInt64 * 2]);
            OddComplexVectorT[iUInt64].real(FileInfoObj.NoiseBufferVectorTRef[iUInt64 * 2 + 1]);
        }
    }

    bool AtHighestScopeLevelBool = false;

    UE_UINT64 nUInt64 = FileInfoObj.LengthUInt64;

    if (!NoiseBufferComplexVectorTRef.empty() && NoiseBufferComplexVectorTRef.size() < 2)
    {
        return;
    }
    else 
    if (!NoiseBufferComplexVectorTRef.empty())
    {
        nUInt64 = NoiseBufferComplexVectorTRef.size();
    }
    else // NoiseBufferComplexVectorTRef.empty()
    {
        NoiseBufferComplexVectorTRef = ComplexVectorT<T>(nUInt64);

        AtHighestScopeLevelBool = true;
    }

    enum class AudioSettingsENUM
    {
        Speed = 1,
        Precision
    };

template<typename T, typename T>
class RangeT


template<short T>
class PlaybackPrecision : public BuildPrecision
{
public:
    // forbid an rvalue constructor //
    explicit PlaybackPrecision(
        T tl = 0, // Lower
        T tu = 8, // Upper
        T ts = 8  // Set
        ) 
    {
        iSettings = BuildSettings(tl, tu, ts);
    };
    virtual std::string FloatPrecision(T ts) override
    {   
        return iSettings.FloatPrecision(ts);
    };
    virtual std::string IntPrecision(T ts) override
    {
        return iSettings.IntPrecision(ts);
    };
    virtual std::string UnsignedIntPrecision(T ts) override
    {
        return iSettings.UnsignedIntPrecision(ts);
    };
private:
    BuildSettings iSettings;
};{

public:
    explicit RangeT(
        T tu = static_cast<T>(0), // Upper
        T tl = static_cast<T>(8), // Lower
        T ts = static_cast<T>(8) // Set
        ) // forbid an rvalue constructor //
    {
        lvalT = static_cast<char>(std::abs<T>(tt%MaxRangeT));
    };
    std::string ValueT(T ts)
    {
        std::string ResultStdString = "UE_FLOAT64";
        static_assert(std::is_integral<T>::value, "RangeT<T> : T must be an integer type");
        T result = (ts != 0) ? static_cast<char>(std::abs<T>(ts % MaxRangeT)) : lvalT;
        if (result <= 1)
        {
            ResultStdString = "char";
        }
        else
        if(result <= 2)
        { 
            ResultStdString = "short"
        }
        else
        if (result <= 3)
        {
            ResultStdString = "int"
        }
        else
        if (result <= 4)
        {
            ResultStdString = "long";
        }
        else
        if (result <= 5)
        {
            ResultStdString = "long long"
        }
        else
        if (result <= 6)
        {
            ResultStdString = "UE_FLOAT16"
        }
        else
        if (result <= 7)
        {
            ResultStdString = "UE_FLOAT32";
        } // else  ResultStdString = "UE_FLOAT64";
        return ResultStdString;
    };
private:
    T MaxRangeT = static_cast<T>(5);
    T lvalT = static_cast<T>(0);
};

void AudioEqualization::iCooleyTukeyFFT(
    FILEINFO_Obj& FileInfoObj,
    ComplexVectorFloat64T& NoiseBufferComplexFloat64
)
{
    bool AtHighestScopeLevelBool = false;

    UE_UINT64 nUInt64 = FileInfoObj.LengthUInt64;

    if (!NoiseBufferComplexFloat64.empty() && NoiseBufferComplexFloat64.size() < 2)
    {
        return;
    }
    else 
    if (!NoiseBufferComplexFloat64.empty())
    {
        nUInt64 = NoiseBufferComplexFloat64.size();
    }
    else // NoiseBufferComplexFloat64.empty()
    {
        NoiseBufferComplexFloat64 = ComplexVectorFloat64T(nUInt64);

        AtHighestScopeLevelBool = true;
    }

    UE_UINT64 nHalfRangeUInt64 = static_cast<UE_UINT64>( nUInt64 / 2);

    ComplexVectorFloat64T EvenComplexVectorFloat64T = ComplexVectorFloat64T(nHalfRangeUInt64);
    ComplexVectorFloat64T OddComplexVectorFloat64T = ComplexVectorFloat64T(nHalfRangeUInt64);

    if(!AtHighestScopeLevelBool)
    {
        for (UE_UINT64 iUInt64 = 0; iUInt64 < nHalfRangeUInt64; iUInt64++)
        {
            EvenComplexVectorFloat64T[iUInt64] = NoiseBufferComplexFloat64[iUInt64 * 2];
            OddComplexVectorFloat64T[iUInt64] = NoiseBufferComplexFloat64[iUInt64 * 2 + 1];
        }
    }
    else
    {
        for (UE_UINT64 iUInt64 = 0; iUInt64 < nHalfRangeUInt64; iUInt64++)
        {
            EvenComplexVectorFloat64T[iUInt64].real(FileInfoObj.NoiseBufferFloat64[iUInt64 * 2]);
            OddComplexVectorFloat64T[iUInt64].real(FileInfoObj.NoiseBufferFloat64[iUInt64 * 2 + 1]);
        }
    }

    iCooleyTukeyFFT(FileInfoObj, EvenComplexVectorFloat64T);
    iCooleyTukeyFFT(FileInfoObj, OddComplexVectorFloat64T);

    ComplexFloat64T 
        wComplexFloat64 = ComplexFloat64T(1.0f), 
        wnComplexFloat64 = ComplexFloat64T(std::cos(2 * M_PI / nUInt64), std::sin(2 * M_PI / nUInt64));

    for (UE_UINT64 kUInt64 = 0; kUInt64 < nHalfRangeUInt64; kUInt64++)
    {
        ComplexFloat64T tComplexFloat64 = wComplexFloat64 + OddComplexVectorFloat64T[kUInt64];
        NoiseBufferComplexFloat64[kUInt64] = EvenComplexVectorFloat64T[kUInt64] + tComplexFloat64;
        NoiseBufferComplexFloat64[kUInt64 + nHalfRangeUInt64] = EvenComplexVectorFloat64T[kUInt64] - tComplexFloat64;
        wComplexFloat64 *= wnComplexFloat64;
    }

    if (AtHighestScopeLevelBool)
    {
        NormalizeAudio(NoiseBufferComplexFloat64);
    }
}

    for (UE_UINT64 kUInt64 = 0; kUInt64 < nHalfRangeUInt64; kUInt64++)
    {
        std::complex < UE_FLOAT64 > tComplexFloat64 = 
            std::polar < UE_FLOAT64 > (1.0f, -2.0f * M_PI * kUInt64 / nUInt64) * 
                OddComplexVectorFloat64T[kUInt64];
        NoiseBufferComplexFloat64[kUInt64] = EvenComplexVectorFloat64T[kUInt64] + tComplexFloat64;
        NoiseBufferComplexFloat64[kUInt64 + nHalfRangeUInt64] = EvenComplexVectorFloat64T[kUInt64] - tComplexFloat64;
    }

using PolarT = std::polar<UE_FLOAT64>;

template <typename T>
PolarT ComplexNumberToPolarT(const T real, const T imag)
{
    T magnitude = std::sqrt(real * real + imag * imag);
    T phase = std::atan2(imag, real);
    return std::polar<T>(magnitude, phase);     
}

using ComplexNumberToPolarFloat64T = ComplexNumberToPolarT<UE_FLOAT64>;

bool AtHighestScopeLevelBool = EvenComplexVectorFloat64.size() == UE_UINT64(FileInfoObj.LengthUInt64 / 2);

template<typename T>
T operator"" _ghz(T iFloat64)
{
    return iFloat64 * 1e9;
}


/********************
* HEADER DECLARATIONS
*********************/

class FMYViewport : public FViewport
{
public:
    virtual void* GetWindow() override;
    virtual void MoveWindow(int32 NewPosX, int32 NewPosY, int32 NewSizeX, int32 NewSizeY) override;
    virtual void Destroy() override;
    virtual bool SetUserFocus(bool bFocus) override;
    virtual bool KeyState(FKey Key) const override;
    virtual int32 GetMouseX() const override;
    virtual int32 GetMouseY() const override;
    virtual void GetMousePos(FIntPoint& MousePosition, const bool bLocalPosition = true) override;
    virtual void SetMouse(int32 x, int32 y) override;
    virtual void ProcessInput(float DeltaTime) override;
    virtual FVector2D VirtualDesktopPixelToViewport(FIntPoint VirtualDesktopPointPx) const override;
    virtual FIntPoint ViewportToVirtualDesktopPixel(FVector2D ViewportCoordinate) const override;
    virtual void InvalidateDisplay() override;
    virtual FViewportFrame* GetViewportFrame() override;
};

class FMYViewportClient : public FViewportClient
{
public:
    FMYViewportClient() {};
    ~FMYViewportClient() {};
    TSharedPtr<FMYViewport> Viewport;
};

class FCamera : public ACameraActor
{
public:
    FCamera() {};
    ~FCamera() {};
};

class FCharacter : public ACharacter
{
public:
    FCharacter() {};
    ~FCharacter() {};
};

class FPlayerController : public APlayerController
{
public:
    FPlayerController() {};
    ~FPlayerController() {};
};

/*******************
* SOURCE DEFINITIONS
********************/

void* FMYViewport::GetWindow()
{
    return nullptr;
}

void FMYViewport::MoveWindow(int32 NewPosX, int32 NewPosY, int32 NewSizeX, int32 NewSizeY)
{
}

void FMYViewport::Destroy()
{
}

bool FMYViewport::SetUserFocus(bool bFocus)
{
    return false;
}

bool FMYViewport::KeyState(FKey Key) const
{
    return false;
}

int32 FMYViewport::GetMouseX() const
{
    return int32();
}

int32 FMYViewport::GetMouseY() const
{
    return int32();
}

void FMYViewport::GetMousePos(FIntPoint& MousePosition, const bool bLocalPosition)
{
}

void FMYViewport::SetMouse(int32 x, int32 y)
{
}

void FMYViewport::ProcessInput(float DeltaTime)
{
}

FVector2D FMYViewport::VirtualDesktopPixelToViewport(FIntPoint VirtualDesktopPointPx) const
{
    return FVector2D();
}

FIntPoint FMYViewport::ViewportToVirtualDesktopPixel(FVector2D ViewportCoordinate) const
{
    return FIntPoint();
}

void FMYViewport::InvalidateDisplay()
{
}

FViewportFrame* FMYViewport::GetViewportFrame()
{
    return nullptr;
}



void FAUDIO_SFX_PLUGINModule::CreatCameraViewportPlayerControllerEtc()
{

    //TObjectPtr<UWorld> World = GEngine->GetWorld();

    //GEngine->GameViewport->AddViewportWidgetContent(
    //    SNew(SMy3DViewport).AddMetaData<FTagMetaData>(FTagMetaData(TEXT("MyViewport")))
    //);

    // Create a camera actor
    //FActorSpawnParameters SpawnParams;
    //SpawnParams.Name = TEXT("MyCamera");
    //TObjectPtr<FCamera> CameraActor = World->SpawnActor<FCamera>(FVector::ZeroVector, FRotator::ZeroRotator, SpawnParams);
    //CameraActor->SetActorLabel(TEXT("MyCameraActor"));

    // Create a 3D viewport
    //TObjectPtr<FMYViewportClient> ViewportClient = new FMYViewportClient();
    //TSharedPtr<FMYViewportClient> ViewportClient = GEngine->GameViewport();
    //ViewportClient->Viewport = MakeShareable(new FMYViewport(ViewportClient));
    //ViewportClient->Viewport->SetSize(FIntPoint(1024, 768));
    //ViewportClient->Viewport->SetInitialSize(FIntPoint(1024, 768));
    //ViewportClient->Viewport->SetViewLocation(FVector::ZeroVector);
    //ViewportClient->Viewport->SetViewRotation(FRotator::ZeroRotator);
    //ViewportClient->Viewport->SetViewTarget(CameraActor);

    // Create a character controller
    //TObjectPtr<FCharacter> Character = World->SpawnActor<FCharacter>(FVector::ZeroVector, FRotator::ZeroRotator, SpawnParams);

    // Set the camera actor as the current player controller's controlled camera
    //TObjectPtr<FPlayerController> PlayerController = (FPlayerController*) GEngine->GetFirstLocalPlayerController(GEngine->GetWorld());
    //PlayerController->SetViewTarget(CameraActor);

    // Create a camera actor
    //TObjectPtr<UEngine> GEngineObjPtr = NewObject<UEngine>();
    World = GEngine->GetWorld(); // GEngineObjPtr->GetWorld(); //
    Camera = World->SpawnActor<ACameraActor>(FVector::ZeroVector, FRotator::ZeroRotator);

    // Set the camera properties
    Camera->SetActorLocation(FVector::ZeroVector);
    Camera->SetActorRotation(FRotator::ZeroRotator);
    Camera->SetActorScale3D(FVector::ZeroVector);

    // Create a player controller
    PlayerController = World->SpawnActor<APlayerController>(FVector::ZeroVector, FRotator::ZeroRotator);

    // Set the player controller's properties
    PlayerController->SetControlRotation(FRotator::ZeroRotator);
    PlayerController->bShowMouseCursor = true;
    PlayerController->bEnableClickEvents = true;
    PlayerController->bEnableMouseOverEvents = true;

    // Create a render target for the viewport

    //ViewportClient = NewObject<UGameViewportClient>();
    ViewportClient = NewObject<FViewportClient>();

    // Set the viewport properties
    ViewportClient->Viewport->SetInitialSize(FIntPoint(1024, 725));

    // Create a render target for the viewport
    //Viewport = NewObject<FViewport>();

    // Set the viewport properties
    //Viewport->SetInitialSize(FIntPoint(1024, 725));
    //Viewport->SetRealtime(true); // real-time rendering
    //Viewport->bIsSlateViewport = true;
}
TSharedRef<SDockTab> FAUDIO_SFX_PLUGINModule::OnSpawnPluginTab(const FSpawnTabArgs& SpawnTabArgs)
{
    //DXRApplication THE_RTX_APP;

    FText WidgetText = FText::Format(
        LOCTEXT("WindowWidgetText", "Add code to {0} in {1} to override this window's contents"),
        FText::FromString(TEXT("FAUDIO_SFX_PLUGINModule::OnSpawnPluginTab")),
        FText::FromString(TEXT("AUDIO_SFX_PLUGIN.cpp"))
        );

    // Init viewport et al.
    CreatCameraViewportPlayerControllerEtc();

    return SNew(SDockTab)
        .TabRole(ETabRole::MajorTab)
        [
            // Put your tab content here!
            //SNew(SViewport)
            /*SNew(SBox)
            .HAlign(HAlign_Fill)
            .VAlign(VAlign_Fill)
            [
                SNew(SViewport)
            ]*/

            //SNew(SMy3DViewport)
            
            SNew(SBox)
            .HAlign(HAlign_Center)
            .VAlign(VAlign_Center)
            [
                SNew(STextBlock)
                .Text(WidgetText)
            ]
        ];
}


 /*   return SNew(SWindow)
        .Title(LOCTEXT("FAUDIO_SFX_PLUGINTabWindowTitle", "The Audio SFX Designer"))
        .ClientSize(FVector2D(1024, 728))
        .CreateTitleBar(true);*/

    return SNew(SDockTab)
        .TabRole(ETabRole::MajorTab)
        [            
           /* SNew(SBox)
            .HAlign(HAlign_Center)
            .VAlign(VAlign_Center)
            [
                SNew(STextBlock)
                .Text(WidgetText)
            ]*/
            WindowObjPtr
        ];



class UMGViewportComponent : public SWindow
{

public:

    UMGViewportComponent();
   ~UMGViewportComponent();

    void OpenAsWindow();
    void SetManualDPIScaling();
    void OverrideWindowManualDPIScaling();

};


class UMGViewportComponent : public SWindow
{

public:

    UMGViewportComponent();
   ~UMGViewportComponent();

public:
    TSharedPtr<UMGViewportComponent> toSharedPtr();

};



UMGViewportComponent::UMGViewportComponent()
{
    this->SetTitle(FText::FromString(TEXT("The Audio SFX Designer")));
    this->bCreateTitleBar = true;

    /*void* WindowHandlePtr = 0;
    uint32 SizeXINT32 = 1024;
    uint32 SizeYINT32 = 728;
    bool isFullcreenBOOL = false;
    EPixelFormat PreferredPixelFormatENUM = EPixelFormat::PF_R32G32B32A32_UINT;

    RHICreateViewport(WindowHandlePtr, SizeXINT32, SizeYINT32, isFullcreenBOOL, PreferredPixelFormatENUM);*/
}

UMGViewportComponent::~UMGViewportComponent()
{
}

TSharedPtr<UMGViewportComponent> UMGViewportComponent::toSharedPtr()
{
    return TSharedPtr<UMGViewportComponent>();
}


    return SNew(SDockTab)
        .TabRole(ETabRole::MajorTab)
        [
            /*SNew(SWindow)
            .Title(LOCTEXT("FAUDIO_SFX_PLUGINTabWindowTitle", "The Audio SFX Designer"))
            .CreateTitleBar(true)*/
            SNew(SWindow)
        ];



UMGViewportComponent::UMGViewportComponent()
{
}

UMGViewportComponent::~UMGViewportComponent()
{
}

//TSharedRef<UMGViewportComponent> UMGViewportComponent::toSharedRef()
//{
//    return TSharedRef<UMGViewportComponent>();
//}

    TSharedRef<SDockTab> MySDockTabObjPtr = SNew(SDockTab).TabRole(ETabRole::MajorTab);

    TSharedRef<SWindow> QuickWindowObjRef = TSharedRef<SWindow>();
    //TSharedRef<UMGViewportComponent> QuickWindowObjRef = MakeSharedRef<UMGViewportComponent>();
    //MySDockTabObjPtr->SetContent(QuickWindowObjRef);

    return MySDockTabObjPtr;


void FAUDIO_SFX_PLUGINModule::CreateCameraViewportPlayerControllerEtc()
{
    //WindowObjPtr = SNew(SWindow)
        //.Title(FText::FromString(TEXT("The Audio SFX Designer")))
        //.CreateTitleBar(true)
        ;
    //WindowObjPtr->SetTitle(FText::FromString(TEXT("The Audio SFX Designer")));
    //WindowObjPtr->bCreateTitleBar = true;
    //WindowObjPtr->SetContent
}


    //TSharedRef<SWindow>(QuickWindowObjRef);
    //TSharedRef<SWindow> QuickWindowObjRef = SNew(SWindow);
    //TSharedRef<UMGViewportComponent> QuickWindowObjRef = MakeSharedRef<UMGViewportComponent>();
    //MySDockTabObjPtr->SetContent(QuickWindowObjRef);

    //TSharedPtr<UMGViewportComponent> QuickWindowObjRef;
    //TSharedRef<UMGViewportComponent> QuickWindowObjRef;
    //UMGViewportComponent QuickWindowObjRef;
    //TSharedRef<SWindow> QuickWindowObjRef;
    //UMGViewportComponent ViewportClientComponent;

    //UMGViewportComponent::FArguments InArgs;
    //QuickWindowObjRef->Construct(InArgs);


//class IModuleInterface;
//class FToolBarBuilder;
//class FMenuBuilder;
//class FViewportClient;
//class UMGViewportComponent;


    SpawnTabArgs.GetTabId();

    if (SpawnTabArgs.GetTabId() == )
    {

    }


    //TSharedRef<UMGViewportComponent> SNWin = SNew(UMGViewportComponent)
        //.Title(FText::FromString(TEXT("The Audio SFX Designer")))
        //.CreateTitleBar(true)
        //.HasCloseButton(false)
        ;

    return SNew(SDockTab)
        .TabRole(ETabRole::MajorTab)
        .Label(inAttributesTXT)
        [
            SNWin
        ]
        ;


void CreateCameraViewportPlayerControllerEtc();

// Init viewport et al.
CreateCameraViewportPlayerControllerEtc();

void FAUDIO_SFX_PLUGINModule::CreateCameraViewportPlayerControllerEtc()
{

}


    //DXRApplication THE_RTX_APP;

    FText WidgetText = FText::Format(
        LOCTEXT("WindowWidgetText", "Add code to {0} in {1} to override this window's contents"),
        FText::FromString(TEXT("FAUDIO_SFX_PLUGINModule::OnSpawnPluginTab")),
        FText::FromString(TEXT("AUDIO_SFX_PLUGIN.cpp"))
        );


    UE_UINT64 iUInt64 = 0;
    for (UE_FLOAT64REF SampleIdxFloat64Ref : FileInfoObj.NoiseBufferFloat64)
    {
        /* UE_UINT64 frequencyUInt64 = 1 << iUInt64; */
        UE_UINT64 amplitude = std::pow(FileInfoObj.BlackNoisePersistenceValueFloat64, iUInt64++);
        SampleIdxFloat64Ref += dis(gen) + amplitude;
    }

class Tone : public 
    BlackNoise, 
    BlueNoise,
    GreyNoise,
    PinkNoise,
    PurpleNoise,
    WhiteNoise//,
    //WhitePerlinNoise
{

public:

    Tone();

    struct NOISE_OBJ
    {
        BlackNoise Black;
        BlueNoise Blue;
        GreyNoise Grey;
        PinkNoise Pink;
        PurpleNoise Purple;
        WhiteNoise White;
       // WhitePerlinNoise Perlin;
    } NoiseObj;

    struct RANDOMTONE_OBJ {

    } RandomToneGenerateObj;
};

/*
class Tone : public 
    BlackNoise, 
    BlueNoise,
    GreyNoise,
    PinkNoise,
    PurpleNoise,
    WhiteNoise,
    WhitePerlinNoise,
    SimplexNoise,
    FractalNoise
{

public:

    Tone();

    struct NOISE_OBJ
    {
        BlackNoise Black;
        BlueNoise Blue;
        GreyNoise Grey;
        PinkNoise Pink;
        PurpleNoise Purple;
        WhiteNoise White;
        WhitePerlinNoise PerlinWhite;
        SimplexNoise PerlinSimplex;
        FractalNoise Fractal;
    } NoiseObj;

};
*/


//Tone::Tone()
//{
//}


    {
        std::cout << "Error - AudioEqualization::CooleyTukeyFFT: invalid parameter, FileInfoObj.LengthUInt64" << std::endl;
        return;
    }